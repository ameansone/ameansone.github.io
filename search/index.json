[{"content":"前言 最近在尝试一探 Linux 内核的究竟，可以说是出师不利，在 start_kernel() 这个公认的内核入口里频频受挫，茫茫然不知如何继续，索性先放一放，好在这几天也不是毫无收获，勉强弄懂了内核从被加载直到调用 start_kernel() 的过程，拿来水一篇文章。\n这篇文章分为两部分，用三个角度来检视 bzImage。其中前半部分我尽量用自己的语言介绍 bzImage，但不会深入；后半部分会顺着 Makefile 和 源码 来探究一些关键细节；三个角度分别是 文件的结构，内存中的布局，以及运行时与文件相关的执行和跳转代码。\nbrief bzImage 是编译 Linux 源码得到的最终文件，也就是一般意义上所说的 Linux 内核，一般它会被安装到 /boot 文件夹内，开机时，由 bootloader 按照协议(x86 boot protocol)从硬盘中载入这个文件至内存中，接着跳转至指定位置，自此，bzImage 接管了这台机器，它作为内核开始运行。\n文件 一般编译成功后，bzImage 会是一个 PE 文件，PE 是 Windows 上的可执行文件类型，同时也是 UEFI 规范中的 EFI 文件格式，Linux 用这种方式实现了 EFI STUB 功能，可以直接通过 UEFI 启动 kernel，从而省去了 bootloader。\n但这个功能和 bootloader 启动并不冲突，因为 UEFI 依赖 PE 文件头 的一些信息来跳转启动，而 bootloader 不依赖文件头，它依赖的信息在 0x200 的位置左右。\n它的 PE 文件头是手动构造出来的，之所以手动构造，是因为 Linux 上没有什么能操作 PE 文件的工具，另一方面，手动构造也能精确控制其中的内容。\n我们可以用 objdump 来简单输出它的部分信息。\n$ objdump -fh arch/x86/boot/bzImage 尽管我们习惯说 “编译” 内核，但 bzImage 不完全是编译出来的，真正编译出的内核主体部分是 vmlinux，这是一个 ELF 文件，可以在编译后的根目录找到，它是真正意义上的内核，开机过程结束后，运行在机器上的内核就是这个文件的内容，但它无法直接被启动，需要进行一系列初始化，我们将这些初始化代码分离出来，再将编译出的文件拼接在一起，构成了 bzImage。\n具体来说，bzImage 由两个文件组成，第1部分是setup.bin，它的内容包括 boot sector 和 setup 代码，它会被载入某个低地址，第2部分是 vmlinux.bin ，它会被载入高地址，文档中约定在 0x100000 的位置。\n注意，vmlinux.bin 不是 vmlinux，但它包含了 vmlinux。它由一系列初始化代码和 vmlinux 编译到一起的产物，它们会配置好机器，最后调用 vmlinux 中的 start_kernel 函数。\n注意，本文中会出现几个名称相近的文件，请注意区分。\n内存 Linux 的文档中规定了应如何载入这个文件，并提供了一些字段和功能，他们被记录在 x86 boot protocol 中。\n前面提到 bzImage 是用两个文件拼接成的，bootloader 在将 bzImage 载入内存时，也会分别载入这两个部分。那么，bootloader 如何知道怎么分开并载入这两个部分（setup.bin 和 vmlinux.bin）呢？\n答案在 x86 boot protocol 中。\n The 32-bit (non-real-mode) kernel starts at offset (setup_sects+1) * 512 in the kernel file (again, if setup_sects == 0 the real value is 4.) It should be loaded at address 0x10000 for Image/zImage kernels and 0x100000 for bzImage kernels.\n 这段话里有两个重点，分别对应了文件和内存\n 内核（vmlinux.bin）从文件（bzImage）中 (setup_sects+1) * 512 的位置开始 内核（vmlinux.bin）应被载入 0x100000 的位置  其中 setup_sects 是从 setup.bin 中读出的一个字段，它位于第一个扇区（前512字节）中的某个特定位置。当 bootloader 载入了 bzImage 的第一个扇区（也是 setup.bin 的第一个扇区）时，就能获得 setup_sects，在此它代表了 setup.bin 的剩余扇区数。\nbootloader 用 setup_sects 确定了 setup.bin 的内容范围，剩下的部分就是 vmlinux.bin 了。接着，bootloader 把 setup.bin 载入至实模式下的某个低地址，把 vmlinux.bin 载入到 0x100000 的地址，其实代码里没有假定这个地址，但 x86 boot protocol 还是约定在这个位置。\n启动 在 x86 boot protocol 中，约定实模式下启动 bzImage 时应跳转至段寄存器偏移 0x20 的位置，它指的就是内存偏移 0x200 的位置，从文件视角来看，内核入口就在文件头偏移 0x200 的位置，也就是第二个扇区。\n实模式下的寻址为段寄存器左移4位加目标地址， $(seg) * 0x10 + $(addr)，写作 $(seg):$(addr)，若内核被载入至 0x90000，写作 9000:0000，那么内核入口就在 9020:0000 的位置，即 0x90200。\nbefore descending 上文是我尽可能简单地总结，而下面的内容基于源码，所以需要一定前置知识，结合官方文档 x86 boot protocol 也更容易理解。\n另外，下文并不包括所有代码，很多地方一带而过，建议自己查阅源码，这里我做例子的版本是 5.14.14，我还建议自己编译一次来查看对应文件，一般编译命令如下\n$ make defconfig $ make bzImage Linux 编译比较费时，在我的机器上，它耗时一小时左右，如果仅对本文的主题——文件结构——感兴趣，可以换下面的方式编译\n$ rm .config $ make tinyconfig $ make menuconfig $ make bzImage 先删除残留 .config，接着 make tinyconfig，它仅配置最必要的功能，可以大大减少编译时间，但这是 32 位配置，下文用 64 位做例子，所以再用 make menuconfig，把 64 bit kernel 打上勾，保存退出，再编译 bzImage，此时仅需几分钟就能编译完成。\n前置知识  C 汇编 链接脚本 Makefile bash 及 bash 脚本  相关链接  x86 boot protocol make linux kernel 5.14.14 源码  descending Makefile 是一个挺神奇又挺麻烦的东西，我们可以轻松的找到最终 target，却要一点点逐级下降寻回它的依赖，好在这里层数不是很多，慢慢来。\nbzImage 我们在 arch/x86/boot/Makefile 内找到这个 target。\nquiet_cmd_image = BUILD $@ silent_redirect_image = \u0026gt;/dev/null cmd_image = $(obj)/tools/build $(obj)/setup.bin $(obj)/vmlinux.bin \\ \t$(obj)/zoffset.h $@ $($(quiet)redirect_image) $(obj)/bzImage: $(obj)/setup.bin $(obj)/vmlinux.bin $(obj)/tools/build FORCE $(call if_changed,image) @$(kecho) \u0026#39;Kernel: $@ is ready\u0026#39; \u0026#39; (#\u0026#39;`cat .version`\u0026#39;)\u0026#39; 这里 if_changed 是一个宏（或者函数），它定义在 scripts/Kbuild.include 中，有兴趣可以去查看它的定义，这里可以简单理解为直接执行 cmd_$(1) ，在这里就是 cmd_image，它就定义在正上方。\nbzImage 依赖于 setup.bin 及 vmlinux.bin，正如之前所说，它是由这两个文件拼接而成，而将它们拼接起来的就是 $(obj)/tools/build。\n$(obj) 的来历比较麻烦，但它的内容很简单，它是当前 Makefile 的文件夹路径，在这里展开来就是 arch/x86/boot/tools/build。\n这个文件是由同目录下的同名源文件编译出的，它会将 setup.bin 和 vmlinux.bin 拼接在一起，生成 bzImage，并向其中填充一些内容——有一些信息我们无法提前获得，所以在 setup.bin 中预留了一些字段，由 build 填充进去。\nzoffset.h 内就包含一部分需要被填充至 bzImage 的内容。这个 target 就定义在同一 Makefile 内，感兴趣可以自己看。\nsetup.bin 这个 target 同样也定义在 arch/x86/boot/Makefile 里，之所以强调一遍，是因为本文不只这一个 Makefile，避免混淆它们。\nOBJCOPYFLAGS_setup.bin\t:= -O binary $(obj)/setup.bin: $(obj)/setup.elf FORCE $(call if_changed,objcopy) 这里的 if_changed 在上面见过，我们知道它会被展开为 cmd_objcopy，但它却没有定义在附近，这是因为一些通用的工具都被封装进了 scripts/Makefile.lib 中，其中 cmd_objcopy 的定义如下\nquiet_cmd_objcopy = OBJCOPY $@ cmd_objcopy = $(OBJCOPY) $(OBJCOPYFLAGS) $(OBJCOPYFLAGS_$(@F)) $\u0026lt; $@ 这里它会使用定义在前面的 OBJCOPYFLAGS_setup.bin，把 cmd_objcopy 展开来大概类似下面这样\nobjcopy -O binary setup.elf setup.bin objcopy -O binary 会生成一个输入文件的 memory dump，就结果来说，它会丢掉输入文件的文件头，符号表重定位表等，只保留代码段数据段等内容。\n在这里，它将 setup.elf 中的文件头等等内容都删去，保存至 setup.bin 中，此时，setup.bin 中几乎完全是源码对应的内容，没有多余的文件头等等，再利用链接脚本，我们几乎可以控制这个文件中的每一个字节。\n还记得吗，bzImage 是一个手动构造的 PE 文件，删去原有的 ELF 文件头，就是构造的第一步。\nsetup.elf $(obj)/setup.elf 就定义在 $(obj)/setup.bin 上面。\nLDFLAGS_setup.elf\t:= -m elf_i386 -T $(obj)/setup.elf: $(src)/setup.ld $(SETUP_OBJS) FORCE $(call if_changed,ld) cmd_ld 和 cmd_objcopy 一样定义在 scripts/Makefile.lib 中。\nSETUP_OBJS 定义在文件内，包括了 arch/x86/boot 下的大部分源文件（的同名目标文件），再加上 $(src)/setup.ld，不难理解，这里是一条链接指令，将这个文件夹下的目标文件按照 setup.ld 的描述链接在一起。\nsetup.ld 中显式指定了段的位置和地址，由此来控制 setup.elf 中的文件内容，用来构造 PE 文件。\nSECTIONS { . = 0; .bstext\t: { *(.bstext) } .bsdata\t: { *(.bsdata) } . = 495; .header\t: { *(.header) } .entrytext\t: { *(.entrytext) } ....... 其中 .bstext，.bsdata，.header，.entrytext 等都定义在 header.S 中。\nheader.S 用汇编一个字节一个字节地构造出了整个 PE 文件头和一些段信息，其中很多内容都初始化为0来留空，这是为了之后用 arch/x86/boot/tools/build 来填充。\n.code16 .section \u0026#34;.bstext\u0026#34;, \u0026#34;ax\u0026#34; .global bootsect_start bootsect_start: #ifdef CONFIG_EFI_STUB # \u0026#34;MZ\u0026#34;, MS-DOS header .word\tMZ_MAGIC #endif 它的第一个字节就是 PE 格式 魔数 MZ，可以看到它是一个可配置选项，不使用这个功能也不影响从 bootloader 启动。\nheader.S 中还包括了一个重要的结构体 hdr，包含了最终生成的文件的一些信息，里面的部分内容同样由 arch/x86/boot/tools/build 填充，之前提到的 setup_sects 就在这个结构体中，build 会计算 setup.bin 的大小，往这个地址填入相应的值。\n之前提到过，从 bootloader 启动时，会直接跳转至 0x200 的位置。header.S 里有一行注释标明了这个位置。\n# offset 512, entry point .globl\t_start _start: # Explicitly enter this as bytes, or the assembler # tries to generate a 3-byte jump here, which causes # everything else to push off to the wrong offset. .byte\t0xeb\t# short (2-byte) jump .byte\tstart_of_setup-1f 1: 这里没有用汇编代码，而是用写字节的方式构造了一个跳转指令，跳转到同文件的 start_of_setup 处，start_of_setup 最终执行 call main，调用了 main 函数。\nmain 函数定义在 同文件夹内的 main.c 中，它的最后一行会调用 go_to_protected_mode()，它位于 pm.c，最后一行同样是一个函数调用，不同的是，它有两个参数。\nprotected_mode_jump(boot_params.hdr.code32_start, (u32)\u0026amp;boot_params + (ds() \u0026lt;\u0026lt; 4)); code32_start 处于 header.S，是 hdr 成员之一，在途中随着 hdr 带进 boot_params 中，它在 header.S 中的定义为\ncode32_start:\t# here loaders can put a different # start address for 32-bit code. .long\t0x100000\t# 0x100000 = default for big kernel 第二个参数是 boot_params 的真实地址，$(seg) * 0x10 + $(addr)。\n我们可以在 pmjump.S 里找到 protected_mode_jump，这里会开启保护模式并最终直接跳转至 code32_start 的位置，也就是 0x100000。\njmpl\t*%eax\t# Jump to the 32-bit entrypoint 还记得吗？0x100000，vmlinux.bin 就在这个地址，终于，我们从 setup.bin 跳转到了 vmlinux.bin 中。\nvmlinux.bin vmlinux.bin 在 makefile 中的定义如下\nOBJCOPYFLAGS_vmlinux.bin := -O binary -R .note -R .comment -S $(obj)/vmlinux.bin: $(obj)/compressed/vmlinux FORCE $(call if_changed,objcopy) 跟前面的 setup.bin 非常相似，输出格式都是 binary，考虑到前一步，我们直接跳转到了 0x100000 的位置，也就是它的文件头部，显然它的文件头部是可执行的代码，所以我们不但要用 objcopy 删掉了它原有的文件头，还需要用链接脚把特定的代码固定在头部。\n跟前面不同的是，这次操作的源文件是另一个目录下的文件 $(obj)/compressed/vmlinux\nvmlinux 注意，这个 vmlinux 不是 根目录下的 vmlinux。\nMakefile 本身对目录不敏感，所以这个 target 也定义在 arch/x86/boot/Makefile 中，但它没有直接生成需要的文件，而是递归地调用了 make，来间接生成需要的文件。\n$(obj)/compressed/vmlinux: FORCE $(Q)$(MAKE) $(build)=$(obj)/compressed $@ $(MAKE) $(build)=xxx 是 Linux 内核编译系统中常见的命令，用来在文件夹中逐级下降编译，这里不深入它的细节，直接打开 arch/x86/boot/compressed/Makefile，找到需要的 target。\nvmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/kernel_info.o $(obj)/head_$(BITS).o \\ \t$(obj)/misc.o $(obj)/string.o $(obj)/cmdline.o $(obj)/error.o \\ \t$(obj)/piggy.o $(obj)/cpuflags.o ...... $(obj)/vmlinux: $(vmlinux-objs-y) $(efi-obj-y) FORCE $(call if_changed,ld) 要注意这里的 $(obj) 跟之前的 $(obj) 已经是不同的内容了，它们分别是它们的当前目录，在这里它是 arch/x86/boot/compressed。\n这个目录下的 vmlinux 是链接出的 ELF 文件，链接的文件大多是当前目录下的代码编译出的目标文件，其中三个比较特殊，vmlinux.lds head_$(BITS).o 和 piggy.o。\npiggy.o piggy.o 很有意思，虽然看起来它像是用代码编译出的目标文件，但它几乎不含哪怕一条代码，它包含了一整个可执行文件，也就是根目录下的 vmlinux，来看看它是如何做到的。\nquiet_cmd_mkpiggy = MKPIGGY $@ cmd_mkpiggy = $(obj)/mkpiggy $\u0026lt; \u0026gt; $@ targets += piggy.S $(obj)/piggy.S: $(obj)/vmlinux.bin.$(suffix-y) $(obj)/mkpiggy FORCE $(call if_changed,mkpiggy) piggy.o 是由 piggy.S 编译出的文件，但 piggy.S 不是一个提前写好的汇编文件，它是用 $(obj)/mkpiggy 自动生成的，piggy.S 的另一个依赖，$(obj)/vmlinux.bin.$(suffix-y) 是一个压缩文件，它根据配置决定选择哪种压缩工具和算法。\nvmlinux.bin.all-y := $(obj)/vmlinux.bin vmlinux.bin.all-$(CONFIG_X86_NEED_RELOCS) += $(obj)/vmlinux.relocs $(obj)/vmlinux.bin.gz: $(vmlinux.bin.all-y) FORCE $(call if_changed,gzip) ...... $(obj)/vmlinux.bin.zst: $(vmlinux.bin.all-y) FORCE $(call if_changed,zstd22) suffix-$(CONFIG_KERNEL_GZIP)\t:= gz ...... suffix-$(CONFIG_KERNEL_ZSTD)\t:= zst 不论哪种工具，它们要压缩的文件是同一个 $(obj)/vmlinux.bin。\nOBJCOPYFLAGS_vmlinux.bin := -R .comment -S $(obj)/vmlinux.bin: vmlinux FORCE $(call if_changed,objcopy) 注意，这里的 $(obj)/vmlinux.bin 是 arch/x86/boot/compressed/vmlinux.bin，而非之前的 arch/x86/boot/vmlinux.bin；\n注意，这里的 vmlinux，是根目录下的 vmlinux，也非刚刚的 arch/x86/boot/compressed/vmlinux。\n这里的 objcopy 不再直接输出 binary 了，它仅对 内核文件 进行了 strip，保留了一个完整的 ELF 文件格式。\n可以说，当前目录下的 vmlinux.bin 和 根目录下的 vmlinux 基本是同一个东西没啥变化。而当前目录下的 vmlinux 却和根目录下的 vmlinux 完全不同，\n再来看 piggy.S，它直接包含了这个压缩后的内核，可以预见，编译后的 piggy.o，包含了一个 .rodata..compressed 的段，这个段是一个完整的压缩后的内核。\n.section \u0026#34;.rodata..compressed\u0026#34;,\u0026#34;a\u0026#34;,@progbits .globl z_input_len z_input_len = 9905201 .globl z_output_len z_output_len = 36765532 .globl input_data, input_data_end input_data: .incbin \u0026#34;arch/x86/boot/compressed/vmlinux.bin.gz\u0026#34; input_data_end: .section \u0026#34;.rodata\u0026#34;,\u0026#34;a\u0026#34;,@progbits .globl input_len input_len: .long 9905201 .globl output_len output_len: .long 36765532 这里用 input_data 和 input_data_end 标明了 这个压缩后的内核的起始地址和结束地址。\n现在，我们知道了真正的内核究竟被塞进了哪里，也知道了如何在内存中找到它，剩下两个问题，1，它是个压缩文件，我们不可能直接执行压缩文件；2，它是个 ELF 文件，我们也不能直接在开机前的环境下直接运行 ELF。\nvmlinux.lds vmlinux.lds 是一个 ld 文件，它由 vmlinux.ld.S 经过预处理生成，跟之前一样，它显式指定了段的位置，再加上前面提到的 objdump -O binary，可以知道，这里放在开头的内容，就是 vmlinux.bin 的头部内容，也是 0x100000 地址的内容。\nSECTIONS { ...... /* Text and read-only data */ .text : AT(ADDR(.text) - LOAD_OFFSET) { _text = .; _stext = .; /* bootstrapping code */ HEAD_TEXT TEXT_TEXT 这里 HEAD_TEXT 处于同目录下的 head_64.S 中，更具体一点，是该文件中的 __HEAD，他们在展开后都是 .head.text。\nhead_64.o head_64.S 有近千行，里面是成吨的架构相关细节，但我们不关心这些细节，我们只关心文件在内存中的结构。\n虽然这一节的标题是 head_64.o，但 它 仅仅是个入口，它和 arch/x86/boot/compressed 目录下的代码一起完成了很多架构相关的工作，但我们仅关心一个东西——文件。\n我们知道 0x100000 的地址上是 vmlinux.bin，它包含了 arch/x86/boot/compressed 目录下的代码 以及压缩后的内核文件，在跳转到这里后，它会把这个压缩后的内核复制到一个“安全”的地方，然后解压出其中的 ELF 文件，最后把 ELF 中的程序段安置在对应地址上。\n复制 head_64.S 代码中有这么一段\n/* * Copy the compressed kernel to the end of our buffer * where decompression in place becomes safe. */ pushq\t%rsi leaq\t(_bss-8)(%rip), %rsi leaq\trva(_bss-8)(%rbx), %rdi movl\t$(_bss - startup_32), %ecx shrl\t$3, %ecx std rep\tmovsq cld popq\t%rsi 这里，会把内存中从 startup_32 至 _bss 的内容复制到 %rbx 指向的位置，其中 startup_32 就定义在这个文件最开始，跟 __HEAD 同一个位置，也就是 vmlinux.bin 的开始，_bss 指的是 vmlinux.ld.S 中的 .bss 段。\n这一段内存，几乎就是 vmlinux.bin 的所有内容，所以我们把 vmlinux.bin 从 0x100000 复制到了 %rbx 指向的位置，但是为什么？\n不久前我们把 vmlinux 压缩进了 piggy.o，现在我们希望将它解压出来。\n如果仅仅是这样，或许用不着这么麻烦，这里要做的是 就地解压，具体一点说，我们要将它解压到 0x100000 的地址上，就是当前 vmlinux.bin 所在的位置。\n如果不做任何准备，任谁都能想象到，解压出的内容会立刻覆盖原有内容，而且，因为是解压，在大多数情况下，解压出的数据都比解压前的更大，解压出的数据会立刻破坏掉未解压的数据甚至代码，让解压几乎不可能完成。\n所以我们将 vmlinux 的内容复制到后面某个位置，在 0x100000 这个地址留出足够的空间，这样就能顺利完成解压过程。\n解压 和 重定位 复制代码下方不远处，就是解压的代码，它调用了 extract_kernel，这个函数定义在 misc.c 中。\n尽管这个函数叫 extract_kernel，但它不仅只解压了内核，还将这个 EFI 文件中的各个程序段挪到相应位置，还顺便处理了重定位，从这个函数返回后，我们又有一个 jmp。\n/* * Jump to the decompressed kernel. */ jmp\t*%rax 这次跳转的地址依然是 0x100000，因为刚刚在挪程序段时，就是以 0x100000 为基准依次复制的，vmlinux 中的第一个程序段就放在这个地址上，所以几乎能确信它一定使用了链接脚本来指定程序段的内容。\n这个链接脚本就是 arch/kernel/vmlinux.ld.S\narch/x86/kernel/ 尽管我们现在还没到 start_kernel，但确实脱离了那些外部代码，真正进入了 vmlinux 之中，但 vmlinux 在解压后又立刻被其中的程序段覆盖，文件的结构不复存在，只剩下程序段安置在对应的内存里，本文的主题也基本到此为止，只剩下顺着代码跳转到 start_kernel 了。\n这里的 vmlinux.ld.S 充满着即视感，它跟 arch/x86/boot/compressed/vmlinux.ld.S 非常像，第一个代码段同样是 HEAD_TEXT，对应的就是这个目录下的 head_64.S。\n在 head_64.S 中，我们最终会跳转到 x86_64_start_kernel，在 head_64.c 中，这个函数最后会调用 x86_64_start_reservations(real_mode_data)，接着，就是最后的最后，start_kernel()。\nvoid __init x86_64_start_reservations(char *real_mode_data) { ...... start_kernel(); } 结语 我没有想到，还没有深入 vmlinux，仅仅外围的代码都让我这么焦头烂额，一方面，这些代码不论是量还是难度都比我想象地更大，我应该再检讨一下自己读代码的思路，不该追求每一行都看懂；另一方面，写作向来不是我的强项，哪怕是技术向的文章都能写得这么痛苦，通篇干瘪无力，事后读来都是一种折磨。不知道我还能否坚持下去，习惯和放弃，也不知哪个先到。\n","date":"2021-10-28T20:49:07+08:00","image":"https://example.com/p/linux-kernel-before-start_kernel/21-10-31_hu906fdcf9ab298d98435c8289b5ee5b22_43119_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/linux-kernel-before-start_kernel/","title":"Linux Kernel: bzImage 文件结构和加载流程"},{"content":"前言 这已经是我第N次尝试搞博客了，但每次都没能继续下去，要说原因，网络上的东西也太多了，我能想到的问题基本都能在网上找到答案。我自己也始终是一个学习者的心态，学了一些东西，却很少产出，连代码都很少写，之前的博客也就难以为继。这一次又想记录点东西，于是就盯上前段时间做过的 CSAPP 实验。\n关于 Arch Lab Why Arch Lab 之所以想记录 CSAPP 的实验，是因为它对我来说有点难度，也挺有意思。但思来想去，CSAPP 的实验大部分都是固定的答案，不论过程如何，解法都是一样，没什么发挥余地，网络上也有不少的文章，不差我这一篇。倒是 Arch Lab，它的 Part C 给了相当的发挥空间，允许自由修改流水线以及函数内容，最后用工具来评分。经过简单搜索，我也没在网络上找到类似的解法，所以我想这个思路大概有一点记录的价值吧。\nArch Lab 介绍 Arch Lab 是 CSAPP 配套实验之一，对应第4章和第5章的部分内容，它提供了一个简单的模拟器，实现了 Y86 指令集，这是一个非常简单的指令集，具体的内容可以翻阅 CSAPP 第4章。\n这个实验包括三个部分，前两个部分都比较简单，分值也较少，这里就不涉及了，会主要着墨在 Part C 部分。\nPart C 允许自由修改 pipe-full.hcl 和 ncopy.ys，接着用 correctness.pl 验证结果是否正确，最后用 benchmark.pl 来评分。\nPart C 要求用 Y86 指令集 在 ncopy.ys 内完成一个功能，并能 在 pipe-full.hcl 描述的流水线下正常工作，且越快越好。\n其中，\npipe-full.hcl 是用 HCL 语言描述的流水线，在 make 时会被编译进模拟器，最后用于评分。HCL 文档可以在下一节找到。\nncopy.ys 的内容是一个函数，功能为把 %rdi 指向的内存复制 %rdx 个 quad 至 %rsi 的位置，并将大于 0 的元素个数保存在 %rax 内。\ncorrectness.pl 可以验证 ncopy.ys 是否实现正确，不加参数运行时，它使用非流水线的模拟器，以避免 pipe-full.hcl 的影响；通过后，再运行 correctness.pl -p 来验证 ncopy.ys 在流水线下是否正确。\nbenchmark.pl 用于评分，评分时用的单位是 CPE，每元素周期数，意为复制每个元素所需要的处理器周期数，benchmark.pl 会运行 65 次，每次分别为 0 - 64 个元素，计算出 CPE，最后取平均数，并换算成分数。\n换算规则为，(10.5 - c) * 20，大于 10.5 时得 0 分，小于 7.5 时获得满分 60 分。\n相关文件  实验指导 模拟器（流水线）文档 HCL 文档 ncopy.ys pipe-full.hcl  Step By Step 实验 Repo\n我将整个实验上传到了这个 repo 中，因为之前做过的部分已经遗失了，所以我只上传了 Arch Lab 相关部分，并且仅完成了其中的 Part C，可以用下面的命令来验证实验结果。\n$ git clone https://github.com/ameansone/csapp-labs.git $ cd csapp-labs/archlab-handout/sim/pipe # 编译 $ (cd ..; make clean; make VERSION=full) # 验证 ncopy.ys 是否运行正确 $ ./correctness.pl # 验证 流水线 是否运行正确 $ (cd ../y86-code; make testpsim) $ (cd ../ptest; make SIM=../pipe/psim TFLAGS=-i) # 验证 ncopy.ys 是否在 流水线 上运行正确 $ ./correctness.pl -p # 评分 $ ./benchmark.pl 不出意外的话，最后得到平均 CPE 为 7.29，分数为 60 分。\n思路 经过简单的搜索，我找到的别人分享的解法都是优化 ncopy.ys ，甚至能拿到满分，令人佩服。我比较笨，也比较懒，只好盯上流水线本身，文档里明说可以随意修改 pipe-full.hcl，除了添加 iaddq 指令外，未必不能有其他作为。\n接下来几节我会着重在 pipe-full.hcl 上，从默认版本开始进行优化，给出 diff 以及分数 用来对比区别。\n至于 ncopy.ys 没有什么特定的思路，写着改着就成现在这样了，所以就直接使用最终的版本，何况互联网上甚至能找到满分的 ncopy.ys，再写只有献丑而已。\n关于 ncopy.ys 的优化思路主要在 数据冒险和控制冒险 以及 循环展开 这两节，考虑到它们在流水线角度的逻辑关系，我把它们放在中间，且没有给出 diff 和分数的对比，一方面是因为直接使用了优化后的版本，另一方面，我希望能维持 pipe-full.hcl 的单一变量，以突出本文主题。\n默认 pipe-full.hcl 使用下面的命令切换到默认的 pipe-full.hcl 和没有使用 iaddq 指令的 ncopy.ys 并评分。\n$ git checkout default pipe-full.hcl $ git checkout without-iaddq ncopy.ys $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 为节省空间，这里和以下都会省去验证结果的步骤，直接评分。\n初始的版本得到平均 CPE 为 8.24，得分 45.2。\niaddq 要减少周期数，文档中首先就给了提示，可以实现 iaddq 指令，替代 addq 指令。\n在 pipe-full.hcl 中实现 iaddq 可以参见这个diff\n实现 iaddq 的 pipe-full.hcl 和使用了这条指令的 ncopy.ys 评分过程如下。\n$ git checkout iaddq pipe-full.hcl $ git checkout master ncopy.ys $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 这时平均 CPE 为 7.87，分数为 52.6。\n数据冒险和控制冒险 在 CSAPP 中还给出了提示，就是减少数据冒险和控制冒险，前者出现在相近的指令需要读写同一寄存器或同一地址时，后者发生在所有需要跳转的地方。\n在流水线上，它们会造成程序得出错误结果，所以流水线会牺牲一定性能来保证正确。因此对于需要性能的程序，要尽力避免出现数据冒险和控制冒险。\n具体来说，对于数据冒险，需要调整读写指令的位置以及对应寄存器与地址，使它们错开，不至于导致流水线暂停；对于控制冒险，则尽可能减少跳转指令，避免控制冒险。\n在整个 ncopy.ys 文件里，大部分都是在重复下面的结构\nJMP_6: mrmovq $8(%rdi), %r11 rmmovq %r10, $(%rsi) andq %r10, %r10 jle JMP_6_1 iaddq $1, %rax JMP_6_1: ... 第一行将下一阶段要用的元素从内存中读至 %r11 中，第二行将上阶段已经读至 %r10 的元素写回内存，接着判断 %r10 是否小于等于0，若是，则跳过下一条指令，若不是，则将 %rax +1。\n整个结构中交替使用 %r10 和 %r11 来保存元素，并将读和写操作分在不同阶段，以避免数据数据冒险。\n循环展开 循环展开一方面可以减少指令数，另一方面也能减少跳转数，避免控制冒险，这里我把 ncopy.ys 简单展开到了6，再多就会超过文件长度限制了。\n分支预测策略：BTFNT 书中还给了一个提示，那就是分支预测策略，默认的实现为 always taken，即在条件跳转中，总是预测条件满足，书上说这种策略的成功率约为 60%；书上还说，BTFNT 策略有约 65% 的成功率，BTFNT，backward taken, forward not taken，即跳转地址低于下一条地址时，预测条件满足，跳转地址高于下一条地址时，预测条件不满足。\n65% 对于 60% 好像没差多少，尤其在这个函数里，大部分条件跳转都是基于元素的值，这将任何策略都变成了 50% 的成功率。\n不过一方面，它给出了选择，允许主动调整代码位置来控制预测条件，另一方面，它是进一步优化的基础，所以我在 pipe-full.hcl 中实现了 BTFNT，为下一步优化做准备。\n实现 BTFNT 的具体内容可以在这个 diff 中找到，我没有写注释，希望没有太难看。\n实现 BTFNT 的内容可以大致分为三个部分，第1部分是预测及预测失败时选择取指地址，第2部分是将 jxx 指令中的 valP 通过 ALU 带到访存阶段寄存器，因为前面会用到它，第3部分是配合第1部分来分条件产生气泡。\n下面是评分的过程，不放心的还可以跑下之前提到的测试，看看这个修改是否破坏了流水线。\n$ git checkout btnft pipe-full.hcl $ git checkout master ncopy.ys $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 这里能得到 平均 CPE 7.81，得分 53.7。这里的些许进步得益于代码位置的调整，将需要循环的部分放在判断代码块上方，并将余数部分放在判断代码块下方，前者在循环多时能最大化流水线，而后者避免流水线把约 1/5 的概率预测为真。\n最终优化 原理 这里缓一缓，来关注一下细节，这一步的优化就在一个小细节里。\n实验要求函数返回小于0的元素的个数，为此，整个函数里充满着类似下面的结构。\n\t... and %r10, %r10 jle JMP_6_1 iaddq 1, %rax JMP_6_1: ... 这里的 jle 依赖于输入值，没办法预测，也不能省略，是无法避免的50% 正确率，不论是 always taken 还是 BTFNT 策略都无济于事。\n不过这里有个小细节，那就是 jle JMP_6_1 与 JMP_6_1 之间只隔了一条指令，结合流水线，就能发现这里有个小小的优化空间。\n现在来看流水线，这个模拟器的流水线共有5个阶段，分别是取指，译码，执行，访存和写回。在目前的实现里，条件跳转指令直到到访存阶段才知道条件是否满足，一旦预测失败，就会往译码和执行这两个阶段插入气泡，原因很简单，这两个阶段寄存器内，都是从“错误” 的地址中取得的指令——大多数情况下都是这样。\n这就是控制冒险，但是如果跳转指令和跳转地址之间只隔了一条指令呢？\n回到前面的例子，jle JMP_6_1 到了访存阶段，同时 iaddq 1, %rax 指令会被载入到执行阶段寄存器中，而 JMP_6_1 所指向的指令会被载入至译码阶段寄存器中，一旦预测失败，这两条指令都被替换成气泡，然后再重新从 JMP_6_1 地址载入指令到译码阶段寄存器中，这里显然浪费了一个周期，如果能避免这里的浪费，让流水线在这里失败时产生一个气泡而非两个，不就能省下一个周期了吗？考虑到预测失败的概率约为50%，且复制每个元素时都要进行一次这样的条件跳转，最后的 CPE 能因此减少约 0.5，对应到分数，能提升近 10 分。\n实现 这个优化的实现参见 这个 diff 。\n这里写了一个 hook，具体原理可以参阅 HCL 文档，相当于在流水线内加了一个寄存器，保存了 执行 阶段的 valP，这是因为流水线寄存器不会保存指令对应的地址，只有译码阶段会保存下一条指令的地址，这里简单地利用了这一特性，但也带来一些问题。\n理想的办法是添加一个寄存器以保存 译码 阶段指令的地址，直接判断 译码 阶段指令的地址是否等于跳转地址，但我不知道这个流水线的细节，不清楚 PC 寄存器是怎么工作的，再加上我是一条懒狗，就选择了最有把握的地方来 hook。\n这样就变成判断 执行 阶段的下一条指令地址是否等于跳转地址，问题在于一些指令可以更改预测地址，所以再将 jxx，call 和 ret 指令排除在外，好在 Y86 指令集够简单，能影响 PC 的指令不多。\n最后就是评分了。\n$ git checkout master . $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 不出意外，会得到之前的结果，平均 CPE 7.29，得分 60。相比前一步的结果进步了 0.52 个 CPE，约为 10.4 分，和推测一样。\n结语 写完后发现意外的长，本想简单介绍下最后一步的优化，不知不觉就变成整个流程了，文字写起来和读起来也是截然不同的感觉，希望这篇文章不至于太难读，就这样吧。\n","date":"2021-10-17T16:52:52+08:00","image":"https://example.com/p/csapp-archlab-a-simple-solution/2021-10-19_01-35_hue4f8f75195f81dbb9b9f92c99c6acf7b_93582_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/csapp-archlab-a-simple-solution/","title":"CSAPP Archlab：优化流水线以提高分数"}]