[{"content":"前言 这已经是我第N次尝试搞博客了，但每次都没能继续下去，要说原因，网络上的东西也太多了，我能想到的问题基本都能在网上找到答案。我自己也始终是一个学习者的心态，学了一些东西，却很少产出，连代码都很少写，之前的博客也就难以为继。这一次又想记录点东西，于是就盯上前段时间做过的 CSAPP 实验。\n关于 Arch Lab Why Arch Lab 之所以想记录 CSAPP 的实验，是因为它对我来说有点难度，也挺有意思。但思来想去，CSAPP 的实验大部分都是固定的答案，不论过程如何，解法都是一样，没什么发挥余地，网络上也有不少的文章，不差我这一篇。倒是 Arch Lab，它的 Part C 给了相当的发挥空间，允许自由修改流水线以及函数内容，最后用工具来评分。经过简单搜索，我也没在网络上找到类似的解法，所以我想这个思路大概有一点记录的价值吧。\nArch Lab 介绍 Arch Lab 是 CSAPP 配套实验之一，对应第4章和第5章的部分内容，它提供了一个简单的模拟器，实现了 Y86 指令集，这是一个非常简单的指令集，具体的内容可以翻阅 CSAPP 第4章。\n这个实验包括三个部分，前两个部分都比较简单，分值也较少，这里就不涉及了，会主要着墨在 Part C 部分。\nPart C 允许自由修改 pipe-full.hcl 和 ncopy.ys，接着用 correctness.pl 验证结果是否正确，最后用 benchmark.pl 来评分。\nPart C 要求用 Y86 指令集 在 ncopy.ys 内完成一个功能，并能 在 pipe-full.hcl 描述的流水线下正常工作，且越快越好。\n其中，\npipe-full.hcl 是用 HCL 语言描述的流水线，在 make 时会被编译进模拟器，最后用于评分。HCL 文档可以在下一节找到。\nncopy.ys 的内容是一个函数，功能为把 %rdi 指向的内存复制 %rdx 个 quad 至 %rsi 的位置，并将大于 0 的元素个数保存在 %rax 内。\ncorrectness.pl 可以验证 ncopy.ys 是否实现正确，不加参数运行时，它使用非流水线的模拟器，以避免 pipe-full.hcl 的影响；通过后，再运行 correctness.pl -p 来验证 ncopy.ys 在流水线下是否正确。\nbenchmark.pl 用于评分，评分时用的单位是 CPE，每元素周期数，意为复制每个元素所需要的处理器周期数，benchmark.pl 会运行 65 次，每次分别为 0 - 64 个元素，计算出 CPE，最后取平均数，并换算成分数。\n换算规则为，(10.5 - c) * 20，大于 10.5 时得 0 分，小于 7.5 时获得满分 60 分。\n相关文件  实验指导 模拟器（流水线）文档 HCL 文档 ncopy.ys pipe-full.hcl  Step By Step 实验 Repo\n我将整个实验上传到了这个 repo 中，因为之前做过的部分已经遗失了，所以我只上传了 Arch Lab 相关部分，并且仅完成了其中的 Part C，可以用下面的命令来验证实验结果。\n$ git clone https://github.com/ameansone/csapp-labs.git $ cd csapp-labs/archlab-handout/sim/pipe # 编译 $ (cd ..; make clean; make VERSION=full) # 验证 ncopy.ys 是否运行正确 $ ./correctness.pl # 验证 流水线 是否运行正确 $ (cd ../y86-code; make testpsim) $ (cd ../ptest; make SIM=../pipe/psim TFLAGS=-i) # 验证 ncopy.ys 是否在 流水线 上运行正确 $ ./correctness.pl -p # 评分 $ ./benchmark.pl 不出意外的话，最后得到平均 CPE 为 7.29，分数为 60 分。\n思路 经过简单的搜索，我找到的别人分享的解法都是优化 ncopy.ys ，甚至能拿到满分，令人佩服。我比较笨，也比较懒，只好盯上流水线本身，文档里明说可以随意修改 pipe-full.hcl，除了添加 iaddq 指令外，未必不能有其他作为。\n接下来几节我会着重在 pipe-full.hcl 上，从默认版本开始进行优化，给出 diff 以及分数 用来对比区别。\n至于 ncopy.ys 没有什么特定的思路，写着改着就成现在这样了，所以就直接使用最终的版本，何况互联网上甚至能找到满分的 ncopy.ys，再写只有献丑而已。\n关于 ncopy.ys 的优化思路主要在 数据冒险和控制冒险 以及 循环展开 这两节，考虑到它们在流水线角度的逻辑关系，我把它们放在中间，且没有给出 diff 和分数的对比，一方面是因为直接使用了优化后的版本，另一方面，我希望能维持 pipe-full.hcl 的单一变量，以突出本文主题。\n默认 pipe-full.hcl 使用下面的命令切换到默认的 pipe-full.hcl 和没有使用 iaddq 指令的 ncopy.ys 并评分。\n$ git checkout default pipe-full.hcl $ git checkout without-iaddq ncopy.ys $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 为节省空间，这里和以下都会省去验证结果的步骤，直接评分。\n初始的版本得到平均 CPE 为 8.24，得分 45.2。\niaddq 要减少周期数，文档中首先就给了提示，可以实现 iaddq 指令，替代 addq 指令。\n在 pipe-full.hcl 中实现 iaddq 可以参见这个diff\n实现 iaddq 的 pipe-full.hcl 和使用了这条指令的 ncopy.ys 评分过程如下。\n$ git checkout iaddq pipe-full.hcl $ git checkout master ncopy.ys $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 这时平均 CPE 为 7.87，分数为 52.6。\n数据冒险和控制冒险 在 CSAPP 中还给出了提示，就是减少数据冒险和控制冒险，前者出现在相近的指令需要读写同一寄存器或同一地址时，后者发生在所有需要跳转的地方。\n在流水线上，它们会造成程序得出错误结果，所以流水线会牺牲一定性能来保证正确。因此对于需要性能的程序，要尽力避免出现数据冒险和控制冒险。\n具体来说，对于数据冒险，需要调整读写指令的位置以及对应寄存器与地址，使它们错开，不至于导致流水线暂停；对于控制冒险，则尽可能减少跳转指令，避免控制冒险。\n在整个 ncopy.ys 文件里，大部分都是在重复下面的结构\nJMP_6: mrmovq $8(%rdi), %r11 rmmovq %r10, $(%rsi) andq %r10, %r10 jle JMP_6_1 iaddq $1, %rax JMP_6_1: ... 第一行将下一阶段要用的元素从内存中读至 %r11 中，第二行将上阶段已经读至 %r10 的元素写回内存，接着判断 %r10 是否小于等于0，若是，则跳过下一条指令，若不是，则将 %rax +1。\n整个结构中交替使用 %r10 和 %r11 来保存元素，并将读和写操作分在不同阶段，以避免数据数据冒险。\n循环展开 循环展开一方面可以减少指令数，另一方面也能减少跳转数，避免控制冒险，这里我把 ncopy.ys 简单展开到了6，再多就会超过文件长度限制了。\n分支预测策略：BTFNT 书中还给了一个提示，那就是分支预测策略，默认的实现为 always taken，即在条件跳转中，总是预测条件满足，书上说这种策略的成功率约为 60%；书上还说，BTFNT 策略有约 65% 的成功率，BTFNT，backward taken, forward not taken，即跳转地址低于下一条地址时，预测条件满足，跳转地址高于下一条地址时，预测条件不满足。\n65% 对于 60% 好像没差多少，尤其在这个函数里，大部分条件跳转都是基于元素的值，这将任何策略都变成了 50% 的成功率。\n不过一方面，它给出了选择，允许主动调整代码位置来控制预测条件，另一方面，它是进一步优化的基础，所以我在 pipe-full.hcl 中实现了 BTFNT，为下一步优化做准备。\n实现 BTFNT 的具体内容可以在这个 diff 中找到，我没有写注释，希望没有太难看。\n实现 BTFNT 的内容可以大致分为三个部分，第1部分是预测及预测失败时选择取指地址，第2部分是将 jxx 指令中的 valP 通过 ALU 带到访存阶段寄存器，因为前面会用到它，第3部分是配合第1部分来分条件产生气泡。\n下面是评分的过程，不放心的还可以跑下之前提到的测试，看看这个修改是否破坏了流水线。\n$ git checkout btnft pipe-full.hcl $ git checkout master ncopy.ys $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 这里能得到 平均 CPE 7.81，得分 53.7。这里的些许进步得益于代码位置的调整，将需要循环的部分放在判断代码块上方，并将余数部分放在判断代码块下方，前者在循环多时能最大化流水线，而后者避免流水线把约 1/5 的概率预测为真。\n最终优化 原理 这里缓一缓，来关注一下细节，这一步的优化就在一个小细节里。\n实验要求函数返回小于0的元素的个数，为此，整个函数里充满着类似下面的结构。\n\t... and %r10, %r10 jle JMP_6_1 iaddq 1, %rax JMP_6_1: ... 这里的 jle 依赖于输入值，没办法预测，也不能省略，是无法避免的50% 正确率，不论是 always taken 还是 BTFNT 策略都无济于事。\n不过这里有个小细节，那就是 jle JMP_6_1 与 JMP_6_1 之间只隔了一条指令，结合流水线，就能发现这里有个小小的优化空间。\n现在来看流水线，这个模拟器的流水线共有5个阶段，分别是取指，译码，执行，访存和写回。在目前的实现里，条件跳转指令直到到访存阶段才知道条件是否满足，一旦预测失败，就会往译码和执行这两个阶段插入气泡，原因很简单，这两个阶段寄存器内，都是从“错误” 的地址中取得的指令——大多数情况下都是这样。\n这就是控制冒险，但是如果跳转指令和跳转地址之间只隔了一条指令呢？\n回到前面的例子，jle JMP_6_1 到了访存阶段，同时 iaddq 1, %rax 指令会被载入到执行阶段寄存器中，而 JMP_6_1 所指向的指令会被载入至译码阶段寄存器中，一旦预测失败，这两条指令都被替换成气泡，然后再重新从 JMP_6_1 地址载入指令到译码阶段寄存器中，这里显然浪费了一个周期，如果能避免这里的浪费，让流水线在这里失败时产生一个气泡而非两个，不就能省下一个周期了吗？考虑到预测失败的概率约为50%，且复制每个元素时都要进行一次这样的条件跳转，最后的 CPE 能因此减少约 0.5，对应到分数，能提升近 10 分。\n实现 这个优化的实现参见 这个 diff 。\n这里写了一个 hook，具体原理可以参阅 HCL 文档，相当于在流水线内加了一个寄存器，保存了 执行 阶段的 valP，这是因为流水线寄存器不会保存指令对应的地址，只有译码阶段会保存下一条指令的地址，这里简单地利用了这一特性，但也带来一些问题。\n理想的办法是添加一个寄存器以保存 译码 阶段指令的地址，直接判断 译码 阶段指令的地址是否等于跳转地址，但我不知道这个流水线的细节，不清楚 PC 寄存器是怎么工作的，再加上我是一条懒狗，就选择了最有把握的地方来 hook。\n这样就变成判断 执行 阶段的下一条指令地址是否等于跳转地址，问题在于一些指令可以更改预测地址，所以再将 jxx，call 和 ret 指令排除在外，好在 Y86 指令集够简单，能影响 PC 的指令不多。\n最后就是评分了。\n$ git checkout master . $ (cd ..; make clean; make VERSION=full) $ ./benchmark.pl 不出意外，会得到之前的结果，平均 CPE 7.29，得分 60。相比前一步的结果进步了 0.52 个 CPE，约为 10.4 分，和推测一样。\n结语 写完后发现意外的长，本想简单介绍下最后一步的优化，不知不觉就变成整个流程了，文字写起来和读起来也是截然不同的感觉，希望这篇文章不至于太难读，就这样吧。\n","date":"2021-10-17T16:52:52+08:00","image":"https://example.com/p/csapp-archlab-a-simple-solution/2021-10-19_01-35_hue4f8f75195f81dbb9b9f92c99c6acf7b_93582_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/csapp-archlab-a-simple-solution/","title":"CSAPP Archlab：优化流水线以提高分数"}]