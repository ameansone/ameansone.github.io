<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>a means one</title><link>https://example.com/</link><description>Recent content on a means one</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 20 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml"/><item><title>CSAPP Archlab：优化流水线以提高分数</title><link>https://example.com/p/csapp-archlab-a-simple-solution/</link><pubDate>Sun, 17 Oct 2021 16:52:52 +0800</pubDate><guid>https://example.com/p/csapp-archlab-a-simple-solution/</guid><description>&lt;img src="https://example.com/p/csapp-archlab-a-simple-solution/2021-10-19_01-35.png" alt="Featured image of post CSAPP Archlab：优化流水线以提高分数" />&lt;h2 id="前言">前言&lt;/h2>
&lt;p>这已经是我第N次尝试搞博客了，但每次都没能继续下去，要说原因，网络上的东西也太多了，我能想到的问题基本都能在网上找到答案。我自己也始终是一个学习者的心态，学了一些东西，却很少产出，连代码都很少写，之前的博客也就难以为继。这一次又想记录点东西，于是就盯上前段时间做过的 CSAPP 实验。&lt;/p>
&lt;h2 id="关于-arch-lab">关于 Arch Lab&lt;/h2>
&lt;h3 id="why-arch-lab">Why Arch Lab&lt;/h3>
&lt;p>之所以想记录 CSAPP 的实验，是因为它对我来说有点难度，也挺有意思。但思来想去，CSAPP 的实验大部分都是固定的答案，不论过程如何，解法都是一样，没什么发挥余地，网络上也有不少的文章，不差我这一篇。倒是 Arch Lab，它的 Part C 给了相当的发挥空间，允许自由修改流水线以及函数内容，最后用工具来评分。经过简单搜索，我也没在网络上找到类似的解法，所以我想这个思路大概有一点记录的价值吧。&lt;/p>
&lt;h3 id="arch-lab-介绍">Arch Lab 介绍&lt;/h3>
&lt;p>Arch Lab 是 CSAPP 配套实验之一，对应第4章和第5章的部分内容，它提供了一个简单的模拟器，实现了 Y86 指令集，这是一个非常简单的指令集，具体的内容可以翻阅 CSAPP 第4章。&lt;/p>
&lt;p>这个实验包括三个部分，前两个部分都比较简单，分值也较少，这里就不涉及了，会主要着墨在 Part C 部分。&lt;/p>
&lt;p>Part C 允许自由修改 &lt;code>pipe-full.hcl&lt;/code> 和 &lt;code>ncopy.ys&lt;/code>，接着用 &lt;code>correctness.pl&lt;/code> 验证结果是否正确，最后用 &lt;code>benchmark.pl&lt;/code> 来评分。&lt;/p>
&lt;p>Part C 要求用 Y86 指令集 在 &lt;code>ncopy.ys&lt;/code> 内完成一个功能，并能 在 &lt;code>pipe-full.hcl&lt;/code> 描述的流水线下正常工作，且越快越好。&lt;/p>
&lt;p>其中，&lt;/p>
&lt;p>&lt;code>pipe-full.hcl&lt;/code> 是用 HCL 语言描述的流水线，在 &lt;code>make&lt;/code> 时会被编译进模拟器，最后用于评分。HCL 文档可以在&lt;a class="link" href="#%e7%9b%b8%e5%85%b3%e6%96%87%e4%bb%b6" >下一节&lt;/a>找到。&lt;/p>
&lt;p>&lt;code>ncopy.ys&lt;/code> 的内容是一个函数，功能为把 &lt;code>%rdi&lt;/code> 指向的内存复制 &lt;code>%rdx&lt;/code> 个 quad 至 &lt;code>%rsi&lt;/code> 的位置，并将大于 0 的元素个数保存在 &lt;code>%rax&lt;/code> 内。&lt;/p>
&lt;p>&lt;code>correctness.pl&lt;/code> 可以验证 &lt;code>ncopy.ys&lt;/code> 是否实现正确，不加参数运行时，它使用非流水线的模拟器，以避免 &lt;code>pipe-full.hcl&lt;/code> 的影响；通过后，再运行 &lt;code>correctness.pl -p&lt;/code> 来验证 &lt;code>ncopy.ys&lt;/code> 在流水线下是否正确。&lt;/p>
&lt;p>&lt;code>benchmark.pl&lt;/code> 用于评分，评分时用的单位是 CPE，每元素周期数，意为复制每个元素所需要的处理器周期数，&lt;code>benchmark.pl&lt;/code> 会运行 65 次，每次分别为 0 - 64 个元素，计算出 CPE，最后取平均数，并换算成分数。&lt;/p>
&lt;p>换算规则为，(10.5 - c) * 20，大于 10.5 时得 0 分，小于 7.5 时获得满分 60 分。&lt;/p>
&lt;h3 id="相关文件">相关文件&lt;/h3>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/ameansone/csapp-labs/blob/master/archlab-handout/archlab.pdf" target="_blank" rel="noopener"
>实验指导&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/ameansone/csapp-labs/blob/master/archlab-handout/simguide.pdf" target="_blank" rel="noopener"
>模拟器（流水线）文档&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/ameansone/csapp-labs/blob/master/archlab-handout/waside-hcl.pdf" target="_blank" rel="noopener"
>HCL 文档&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/ameansone/csapp-labs/blob/master/archlab-handout/sim/pipe/ncopy.ys" target="_blank" rel="noopener"
>ncopy.ys&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/ameansone/csapp-labs/blob/master/archlab-handout/sim/pipe/pipe-full.hcl" target="_blank" rel="noopener"
>pipe-full.hcl&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="step-by-step">Step By Step&lt;/h2>
&lt;p>&lt;a class="link" href="https://github.com/ameansone/csapp-labs" target="_blank" rel="noopener"
>&lt;strong>实验 Repo&lt;/strong>&lt;/a>&lt;/p>
&lt;p>我将整个实验上传到了这个 repo 中，因为之前做过的部分已经遗失了，所以我只上传了 Arch Lab 相关部分，并且仅完成了其中的 Part C，可以用下面的命令来验证实验结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ git clone https://github.com/ameansone/csapp-labs.git
$ &lt;span class="nb">cd&lt;/span> csapp-labs/archlab-handout/sim/pipe
&lt;span class="c1"># 编译&lt;/span>
$ &lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> ..&lt;span class="p">;&lt;/span> make clean&lt;span class="p">;&lt;/span> make &lt;span class="nv">VERSION&lt;/span>&lt;span class="o">=&lt;/span>full&lt;span class="o">)&lt;/span>
&lt;span class="c1"># 验证 ncopy.ys 是否运行正确&lt;/span>
$ ./correctness.pl
&lt;span class="c1"># 验证 流水线 是否运行正确&lt;/span>
$ &lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> ../y86-code&lt;span class="p">;&lt;/span> make testpsim&lt;span class="o">)&lt;/span>
$ &lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> ../ptest&lt;span class="p">;&lt;/span> make &lt;span class="nv">SIM&lt;/span>&lt;span class="o">=&lt;/span>../pipe/psim &lt;span class="nv">TFLAGS&lt;/span>&lt;span class="o">=&lt;/span>-i&lt;span class="o">)&lt;/span>
&lt;span class="c1"># 验证 ncopy.ys 是否在 流水线 上运行正确&lt;/span>
$ ./correctness.pl -p
&lt;span class="c1"># 评分&lt;/span>
$ ./benchmark.pl
&lt;/code>&lt;/pre>&lt;/div>&lt;p>不出意外的话，最后得到平均 CPE 为 7.29，分数为 60 分。&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>经过简单的搜索，我找到的别人分享的解法都是优化 &lt;code>ncopy.ys&lt;/code> ，甚至能拿到满分，令人佩服。我比较笨，也比较懒，只好盯上流水线本身，文档里明说可以随意修改 &lt;code>pipe-full.hcl&lt;/code>，除了添加 &lt;code>iaddq&lt;/code> 指令外，未必不能有其他作为。&lt;/p>
&lt;p>接下来几节我会着重在 &lt;code>pipe-full.hcl&lt;/code> 上，从默认版本开始进行优化，给出 diff 以及分数 用来对比区别。&lt;/p>
&lt;p>至于 &lt;code>ncopy.ys&lt;/code> 没有什么特定的思路，写着改着就成现在这样了，所以就直接使用最终的版本，何况互联网上甚至能找到满分的 &lt;code>ncopy.ys&lt;/code>，再写只有献丑而已。&lt;/p>
&lt;p>关于 &lt;code>ncopy.ys&lt;/code> 的优化思路主要在 &lt;a class="link" href="#%e6%95%b0%e6%8d%ae%e5%86%92%e9%99%a9%e5%92%8c%e6%8e%a7%e5%88%b6%e5%86%92%e9%99%a9" >数据冒险和控制冒险&lt;/a> 以及 &lt;a class="link" href="#%e5%be%aa%e7%8e%af%e5%b1%95%e5%bc%80" >循环展开&lt;/a> 这两节，考虑到它们在流水线角度的逻辑关系，我把它们放在中间，且没有给出 diff 和分数的对比，一方面是因为直接使用了优化后的版本，另一方面，我希望能维持 &lt;code>pipe-full.hcl&lt;/code> 的单一变量，以突出本文主题。&lt;/p>
&lt;h3 id="默认-pipe-fullhcl">默认 &lt;code>pipe-full.hcl&lt;/code>&lt;/h3>
&lt;p>使用下面的命令切换到默认的 &lt;code>pipe-full.hcl&lt;/code> 和没有使用 &lt;code>iaddq&lt;/code> 指令的 &lt;code>ncopy.ys&lt;/code> 并评分。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ git checkout default pipe-full.hcl
$ git checkout without-iaddq ncopy.ys
$ &lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> ..&lt;span class="p">;&lt;/span> make clean&lt;span class="p">;&lt;/span> make &lt;span class="nv">VERSION&lt;/span>&lt;span class="o">=&lt;/span>full&lt;span class="o">)&lt;/span>
$ ./benchmark.pl
&lt;/code>&lt;/pre>&lt;/div>&lt;p>为节省空间，这里和以下都会省去验证结果的步骤，直接评分。&lt;/p>
&lt;p>初始的版本得到平均 CPE 为 8.24，得分 45.2。&lt;/p>
&lt;h3 id="iaddq">iaddq&lt;/h3>
&lt;p>要减少周期数，文档中首先就给了提示，可以实现 &lt;code>iaddq&lt;/code> 指令，替代 &lt;code>addq&lt;/code> 指令。&lt;/p>
&lt;p>在 &lt;code>pipe-full.hcl&lt;/code> 中实现 &lt;code>iaddq&lt;/code> 可以参见&lt;a class="link" href="https://github.com/ameansone/csapp-labs/commit/972f5cc28622016c64069f13f665c6a3989ec53e" target="_blank" rel="noopener"
>这个diff&lt;/a>&lt;/p>
&lt;p>实现 &lt;code>iaddq&lt;/code> 的 &lt;code>pipe-full.hcl&lt;/code> 和使用了这条指令的 &lt;code>ncopy.ys&lt;/code> 评分过程如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ git checkout iaddq pipe-full.hcl
$ git checkout master ncopy.ys
$ &lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> ..&lt;span class="p">;&lt;/span> make clean&lt;span class="p">;&lt;/span> make &lt;span class="nv">VERSION&lt;/span>&lt;span class="o">=&lt;/span>full&lt;span class="o">)&lt;/span>
$ ./benchmark.pl
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这时平均 CPE 为 7.87，分数为 52.6。&lt;/p>
&lt;h3 id="数据冒险和控制冒险">数据冒险和控制冒险&lt;/h3>
&lt;p>在 CSAPP 中还给出了提示，就是减少数据冒险和控制冒险，前者出现在相近的指令需要读写同一寄存器或同一地址时，后者发生在所有需要跳转的地方。&lt;/p>
&lt;p>在流水线上，它们会造成程序得出错误结果，所以流水线会牺牲一定性能来保证正确。因此对于需要性能的程序，要尽力避免出现数据冒险和控制冒险。&lt;/p>
&lt;p>具体来说，对于数据冒险，需要调整读写指令的位置以及对应寄存器与地址，使它们错开，不至于导致流水线暂停；对于控制冒险，则尽可能减少跳转指令，避免控制冒险。&lt;/p>
&lt;p>在整个 &lt;code>ncopy.ys&lt;/code> 文件里，大部分都是在重复下面的结构&lt;/p>
&lt;pre tabindex="0">&lt;code>JMP_6:
mrmovq $8(%rdi), %r11
rmmovq %r10, $(%rsi)
andq %r10, %r10
jle JMP_6_1
iaddq $1, %rax
JMP_6_1:
...
&lt;/code>&lt;/pre>&lt;p>第一行将下一阶段要用的元素从内存中读至 &lt;code>%r11&lt;/code> 中，第二行将上阶段已经读至 &lt;code>%r10&lt;/code> 的元素写回内存，接着判断 &lt;code>%r10&lt;/code> 是否小于等于0，若是，则跳过下一条指令，若不是，则将 &lt;code>%rax&lt;/code> +1。&lt;/p>
&lt;p>整个结构中交替使用 &lt;code>%r10&lt;/code> 和 &lt;code>%r11&lt;/code> 来保存元素，并将读和写操作分在不同阶段，以避免数据数据冒险。&lt;/p>
&lt;h3 id="循环展开">循环展开&lt;/h3>
&lt;p>循环展开一方面可以减少指令数，另一方面也能减少跳转数，避免控制冒险，这里我把 &lt;code>ncopy.ys&lt;/code> 简单展开到了6，再多就会超过文件长度限制了。&lt;/p>
&lt;h3 id="分支预测策略btfnt">分支预测策略：BTFNT&lt;/h3>
&lt;p>书中还给了一个提示，那就是分支预测策略，默认的实现为 always taken，即在条件跳转中，总是预测条件满足，书上说这种策略的成功率约为 60%；书上还说，BTFNT 策略有约 65% 的成功率，BTFNT，backward taken, forward not taken，即跳转地址低于下一条地址时，预测条件满足，跳转地址高于下一条地址时，预测条件不满足。&lt;/p>
&lt;p>65% 对于 60% 好像没差多少，尤其在这个函数里，大部分条件跳转都是基于元素的值，这将任何策略都变成了 50% 的成功率。&lt;/p>
&lt;p>不过一方面，它给出了选择，允许主动调整代码位置来控制预测条件，另一方面，它是进一步优化的基础，所以我在 &lt;code>pipe-full.hcl&lt;/code> 中实现了 BTFNT，为下一步优化做准备。&lt;/p>
&lt;p>实现 BTFNT 的具体内容可以在&lt;a class="link" href="https://github.com/ameansone/csapp-labs/commit/a8752678b33989d2a179f0564132797d4b614e61" target="_blank" rel="noopener"
>这个 diff&lt;/a> 中找到，我没有写注释，希望没有太难看。&lt;/p>
&lt;p>实现 BTFNT 的内容可以大致分为三个部分，第1部分是预测及预测失败时选择&lt;code>取指&lt;/code>地址，第2部分是将 &lt;code>jxx&lt;/code> 指令中的 &lt;code>valP&lt;/code> 通过 ALU 带到&lt;code>访存&lt;/code>阶段寄存器，因为前面会用到它，第3部分是配合第1部分来分条件产生气泡。&lt;/p>
&lt;p>下面是评分的过程，不放心的还可以跑下之前提到的测试，看看这个修改是否破坏了流水线。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ git checkout btnft pipe-full.hcl
$ git checkout master ncopy.ys
$ &lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> ..&lt;span class="p">;&lt;/span> make clean&lt;span class="p">;&lt;/span> make &lt;span class="nv">VERSION&lt;/span>&lt;span class="o">=&lt;/span>full&lt;span class="o">)&lt;/span>
$ ./benchmark.pl
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里能得到 平均 CPE 7.81，得分 53.7。这里的些许进步得益于代码位置的调整，将需要循环的部分放在判断代码块上方，并将余数部分放在判断代码块下方，前者在循环多时能最大化流水线，而后者避免流水线把约 1/5 的概率预测为真。&lt;/p>
&lt;h3 id="最终优化">最终优化&lt;/h3>
&lt;h4 id="原理">原理&lt;/h4>
&lt;p>这里缓一缓，来关注一下细节，这一步的优化就在一个小细节里。&lt;/p>
&lt;p>实验要求函数返回小于0的元素的个数，为此，整个函数里充满着类似下面的结构。&lt;/p>
&lt;pre tabindex="0">&lt;code> ...
and %r10, %r10
jle JMP_6_1
iaddq 1, %rax
JMP_6_1:
...
&lt;/code>&lt;/pre>&lt;p>这里的 &lt;code>jle&lt;/code> 依赖于输入值，没办法预测，也不能省略，是无法避免的50% 正确率，不论是 always taken 还是 BTFNT 策略都无济于事。&lt;/p>
&lt;p>不过这里有个小细节，那就是 &lt;code>jle JMP_6_1&lt;/code> 与 &lt;code>JMP_6_1&lt;/code> 之间&lt;strong>只隔了一条指令&lt;/strong>，结合流水线，就能发现这里有个小小的优化空间。&lt;/p>
&lt;p>现在来看流水线，这个模拟器的流水线共有5个阶段，分别是&lt;code>取指&lt;/code>，&lt;code>译码&lt;/code>，&lt;code>执行&lt;/code>，&lt;code>访存&lt;/code>和&lt;code>写回&lt;/code>。在目前的实现里，条件跳转指令直到到&lt;code>访存&lt;/code>阶段才知道条件是否满足，一旦预测失败，就会往&lt;code>译码&lt;/code>和&lt;code>执行&lt;/code>这两个阶段插入气泡，原因很简单，这两个阶段寄存器内，都是从“错误” 的地址中取得的指令——大多数情况下都是这样。&lt;/p>
&lt;p>这就是控制冒险，但是如果跳转指令和跳转地址之间&lt;strong>只隔了一条指令&lt;/strong>呢？&lt;/p>
&lt;p>回到前面的例子，&lt;code>jle JMP_6_1&lt;/code> 到了&lt;code>访存&lt;/code>阶段，同时 &lt;code>iaddq 1, %rax&lt;/code> 指令会被载入到&lt;code>执行&lt;/code>阶段寄存器中，而 &lt;code>JMP_6_1&lt;/code> 所指向的指令会被载入至&lt;code>译码&lt;/code>阶段寄存器中，一旦预测失败，这两条指令都被替换成气泡，然后再&lt;strong>重新&lt;/strong>从 &lt;code>JMP_6_1&lt;/code> 地址载入指令到&lt;code>译码&lt;/code>阶段寄存器中，这里显然浪费了一个周期，如果能避免这里的浪费，让流水线在这里失败时产生一个气泡而非两个，不就能省下一个周期了吗？考虑到预测失败的概率约为50%，且复制每个元素时都要进行一次这样的条件跳转，最后的 CPE 能因此减少约 0.5，对应到分数，能提升近 10 分。&lt;/p>
&lt;h4 id="实现">实现&lt;/h4>
&lt;p>这个优化的实现参见 &lt;a class="link" href="https://github.com/ameansone/csapp-labs/commit/17bffd2e95ccc36067c5f3e9ad38accc0c1942fe" target="_blank" rel="noopener"
>这个 diff&lt;/a> 。&lt;/p>
&lt;p>这里写了一个 hook，具体原理可以参阅 &lt;a class="link" href="#%e7%9b%b8%e5%85%b3%e6%96%87%e4%bb%b6" >HCL 文档&lt;/a>，相当于在流水线内加了一个寄存器，保存了 &lt;code>执行&lt;/code> 阶段的 &lt;code>valP&lt;/code>，这是因为流水线寄存器不会保存指令对应的地址，只有&lt;code>译码&lt;/code>阶段会保存下一条指令的地址，这里简单地利用了这一特性，但也带来一些问题。&lt;/p>
&lt;p>理想的办法是添加一个寄存器以保存 &lt;code>译码&lt;/code> 阶段指令的地址，直接判断 &lt;code>译码&lt;/code> 阶段指令的地址是否等于跳转地址，但我不知道这个流水线的细节，不清楚 &lt;code>PC&lt;/code> 寄存器是怎么工作的，再加上我是一条懒狗，就选择了最有把握的地方来 hook。&lt;/p>
&lt;p>这样就变成判断 &lt;code>执行&lt;/code> 阶段的下一条指令地址是否等于跳转地址，问题在于一些指令可以更改预测地址，所以再将 &lt;code>jxx&lt;/code>，&lt;code>call&lt;/code> 和 &lt;code>ret&lt;/code> 指令排除在外，好在 Y86 指令集够简单，能影响 &lt;code>PC&lt;/code> 的指令不多。&lt;/p>
&lt;p>最后就是评分了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">$ git checkout master .
$ &lt;span class="o">(&lt;/span>&lt;span class="nb">cd&lt;/span> ..&lt;span class="p">;&lt;/span> make clean&lt;span class="p">;&lt;/span> make &lt;span class="nv">VERSION&lt;/span>&lt;span class="o">=&lt;/span>full&lt;span class="o">)&lt;/span>
$ ./benchmark.pl
&lt;/code>&lt;/pre>&lt;/div>&lt;p>不出意外，会得到之前的结果，平均 CPE 7.29，得分 60。相比前一步的结果进步了 0.52 个 CPE，约为 10.4 分，和推测一样。&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>写完后发现意外的长，本想简单介绍下最后一步的优化，不知不觉就变成整个流程了，文字写起来和读起来也是截然不同的感觉，希望这篇文章不至于太难读，就这样吧。&lt;/p></description></item></channel></rss>